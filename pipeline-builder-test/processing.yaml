pipelines :
    bmode_pipeline :
        nodes :
            node_1:
                #gets the transform object from a factory will determine the ports
                #and name at runtime
                #if you create a node with a function with no inputs it will
                #be created with a source node and will be called repeatedly
                type : input_node
                transform :  "source_1"
                concurrency : 1 #serial would be ignored in this case as it is a source
                input_ports : []
                output_ports : [source_1_output] #sources have no input ports
            node_2 :
                type : split_node
                transform : ""
                concurrency : 1
                input_ports : [node_2_input]
                output_ports : [one,two]
            node_3 :
                type : function_node
                transform : "trans_1"
                concurrency : 0 #serial
                input_ports : [node_3_input_0]
                output_ports : [node_3_output_0]
                
            node_5 :
                type : function_node
                transform : "trans_2"
                concurrency : 0 #serial
                input_ports : [node_5_input]
                output_ports : [node_5_output_0]
            
            node_6:
                type : join_node
                transform: ""
                concurrency : 1
                input_ports : [join_1, join_2]
                output_ports : [join_out]
            
            node_7:
                type: sink_node
                transform: "sink_1"
                concurrency : 1
                input_ports : [sink_1]
                output_ports : []
                
        edges :
            #Sequencial connection
            edge_1 :
                start : source_1_output
                end : node_2_input
            #trigger nodes 3 and 4 from 2
            edge_2 :
                start : one
                end : node_3_input_0
            edge_3 :
                start : two
                end : node_5_input
            edge_4 :
                start : node_3_output_0
                end : join_1
            edge_5 :
                start : node_5_output_0
                end : join_2
            edge_6 :
                start : join_out
                end : sink_1
            
            #will have to write a dyanmic splitting node for dyanamic
            #splitting of data into different streams
            #we can write generic export functions here... Maybe overlap
            #avro??? How cool would that be?
    doppler_pipeline :
        status : "unimplemented"
    angiography_pipeline :
        status : "unimplemented"
    cmode_pipeline : 
        status : "unimplemented"